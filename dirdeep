#!/usr/bin/perl 
use 5.014 ; use strict ; use warnings  ;
use feature qw [ say ] ;
#use Time::HiRes qw[gettimeofday tv_interval] ; my $time_start = [ gettimeofday ] ; 
use Term::ANSIColor qw [ :constants color ] ; $Term::ANSIColor::AUTORESET = 1 ; 
use File::Spec::Functions qw[ catfile splitdir ] ; 
use Getopt::Std ; getopts 's:g:' , \my%o ; 

sub get_dirs () { 
  opendir my $dh , '.' or warn $_[0] ; 
  my @dirs = grep { ! /\A\.{1,2}\Z/ && -d $_ } readdir $dh ; #readdir $dh ; # 隠しファイルの処理も加えたい <-- -d に限定している
  #print FAINT map "[$_]" , @dirs ;
  chdir $dh ;
  return @dirs ; 
}

defined $o{s} ? ( srand $o{s} )  : ( $o{s} = srand ) ; # ランダムseed 
$o{g} //= 5 ;


END{
 print RESET "" ; print rand ;
 print STDERR CYAN "Used random seed = $o{s}\n";
} ;


my $I = catfile '' , '' ; # OS毎に異なる可能性のある、ファイルパスの区切り文字を取得。 
my $start_dir = $ARGV [0] // "." ;
my $root = ::dirtree -> new () ;
chdir $start_dir or die ;#say map "[$_]" , & get_dirs ( $start_dir ) ;

package dirtree ;
use 5.014 ; use strict ; use warnings ;
use List::Util qw [ reduce ] ;
use Term::ANSIColor qw [ :constants color ] ; $Term::ANSIColor::AUTORESET = 1 ; 
our $m = 0 ;

#sub new { my %keep = { "name" => $_[1] , children => [] , parent => undef } ; bless \%keep ; } 
#sub new { my %keep = () ; bless \%keep ; } 
sub new { my $R = {} ; bless $R ; } # 上記で初期化のやり方が正しいのどうか気になっている

sub build_recursive ( $$ ) { #  第1引数に子ディレクトリの名前
	if  ( $m < $_[2]) { $m = $_[2] }; #print YELLOW " $m "}
	opendir my $dh , '.' ;
	#print YELLOW "[ $_[1] ]" ;
	chdir $_[1] or do { warn FAINT RED $_ ; return }  ;
	my $ch = new ( undef ) ; #my $ch = new ( $_[1] ) ; 
	push @{ $_[0] -> { children } } , $ch ;
	$ch -> { name } = $_[1] ;
	$ch -> { parent } = $_[0] ;
	$ch -> { d } = $_[2] ; # 深さを代入 # depth distance 
	$ch -> build_recursive ( $_  , $_[2] + 1 ) for ::get_dirs ; # $_[1] ) ;
	chdir $dh ; 
}
#no warnings ;
sub scan () { 
   no warnings ;  ## <<---- <<--- ここはもんだいです
	return $_[0] if ! defined $_[0] -> { children }  ;
    #$|=  1 ; say STDERR FAINT BRIGHT_BLUE "$_[0]->{name}, $_[0]->{d}, " , map "[$_->{name}]" , @{$_[0]->{children}} ;  
	#reduce { $a->{d} > $b->{d}  ? $a : $b } map { $_ -> scan () }  @{ $_[0] -> {children} } ;
    reduce { $a->{d} > $b->{d}  ? $a : $b } map { ($_->scan() , $_ ) }  @{ $_[0] -> {children} } ;
    # 最も大きいもので最初のものとなる。複数の場合の対処はどうしたものか
}

sub pathProc () { 
	my $watch = $_[0] ;
	my @pathProc = () ; 
	while ( $watch->{parent}{name} ) {
	   #$watch -> {d} = 0 ; # <--
	   $watch -> rebuild ( 0 ) ; #<--
       unshift @pathProc , $watch->{name} ;
	   $watch = $watch -> {parent} ;
	} 
	return join $I , @pathProc ;
}

sub rebuild ($){ 
	my ( $watch , $d ) = @_ ;#$_[0] ;
	$watch -> {d} = $d ;
	$_ -> rebuild ( $d +1 ) for grep { $_->{d} >0 }  @{ $watch -> {children} } ;
}

package main ;
$root -> build_recursive ( "." , 0 ) ; #  第二引数 my $depth = 0 ;
my ( $first , $deepest , $dd , $p ) ;
$first = $root -> {children}[0];

for ( 1..$o{g} ) { 
  $deepest = $first -> scan ;
  $dd = $deepest -> {d} ;
  $p = $deepest -> pathProc ;
  say CYAN "$deepest->{name}, $dd, $p" ; 
}


exit 0 ;

